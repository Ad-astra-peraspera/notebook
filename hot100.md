# 1 哈希表

## 1 [1.两数之和](https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked)

`````python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dic = {}
        for i in range(len(nums)):
            if target - nums[i] in dic:
                return i, dic[target - nums[i]]
            else:
                dic[nums[i]] = i
`````



## 2.  [49.字母异位词分组](https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-100-liked)

**1.defaultdict(list) 可以创建一个默认的空列表**

```python
from collections import defaultdict

d = defaultdict(list)
d['a'].append('eat')
d['a'].append('tea')

print(d)
# {'a': ['eat', 'tea']}

```

**2.两个字母异位词，排序后一定完全相同***

```python
s = "tea"
sorted_s = sorted(s)
print(sorted_s)
#['a', 'e', 't']

```

也就是说：

> `sorted(s)` 会把字符串当作字符序列，然后按字母顺序返回一个**排序后的列表**。

但注意！
 它返回的是**列表**，不是字符串。
 所以我们通常要用 `''.join()` 把它拼回成字符串：

```python
sorted_s = ''.join(sorted(s))
print(sorted_s)
# "aet"

```


代码：

```python
from collections import defaultdict
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        ans = defaultdict(list)
        for s in strs:
            s_sorted = "".join(sorted(s))
            ans[s_sorted].append(s) # 这里类似于{'a': ['eat', 'tea']}
        
        return list(ans.values()) #这里需要注意 因为这里相当于是还要给答案转为list才符合题目要求。没有list只会输出一个可迭代对象
```



## 3 [128.最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked)

1.sort() 与sorted

**`sorted(iterable)`** 会返回一个**新的已排序列表**，不会在原对象上修改。

原对象如果是 `list`，它本身不会被改变。

`sorted()`：**返回一个新列表**（适用于任何可迭代对象）

`list.sort()`：**就地排序**，**返回值为 None**

```python
nums = [3, 1, 2]
res = sorted(nums)
print(res)   # [1, 2, 3]
print(nums)  # [3, 1, 2] 原列表没变
nums = [3, 1, 2]
nums.sort()
print(nums)  # [1, 2, 3]

```



```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        # 排序
        if not nums: return 0
        nums.sort()
        ans = 1
        seq = 1
        for i in range(len(nums) - 1):
            if nums[i + 1] - nums[i] == 1:
                seq += 1
            elif nums[i + 1] - nums[i] > 1:
                ans = max(ans, seq )
                seq = 1
        ans = max(ans, seq)   
        return ans
        # max(ans)
```



++++

# 2 双指针

## 1 移动零

**值得重新做**

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        if not nums: return 0
        j = 0
        for i in range(len(nums)):
            if nums[i]:
                nums[j] = nums[i]
                j += 1
        for i in range(j, len(nums)):
            nums[i] = 0
```

## 2  11.盛最多水的容器

在每个状态下，无论长板或短板向中间收窄一格，都会导致水槽 底边宽度 −1 变短：

若向内 移动短板 ，水槽的短板 min(h[i],h[j]) 可能变大，**因此下个水槽的面积 可能增大 。**
若向内 移动长板 ，水槽的短板 min(h[i],h[j]) 不变或变小，**因此下个水槽的面积 一定变小 。**
因此，初始化双指针分列水槽左右两端，循环每轮将短板向内移动一格，并更新面积最大值，直到两指针相遇时跳出；即可获得最大面积。

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        l = 0
        r = len(height) - 1
        ans = 0
        while l < r:
            water = min(height[l], height[r]) * (r - l)
            ans = max(water, ans)
            if height[l] < height[r]:
                l += 1
            else:
                r -= 1
        return ans

```

## 3  15.三数之和

***需要再做一遍，里面的去重等有点绕***

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        '''
        1，在同一个答案内，同一个数字只能使用一次
        2，三元组不可以重复
        '''
        #初始化及剪枝操作
        ans = []
        if not nums:
            return ans
        nums.sort()# 题目明确说明输出的顺序和三元组的顺序不重要
        if nums[0] > 0:
            return ans
        n = len(nums)
        
        # 开始固定i，利用双指针lr求解
        for i in range(n - 2):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            l = i + 1
            r = n - 1
            while l < r:
                s = nums[i] + nums[r] +nums[l]
                if s == 0:
                    ans.append([nums[i], nums[l], nums[r]])
                    while l < r and nums[l] == nums[l + 1]: 
                        l += 1
                    while l < r and nums[r] == nums[r - 1]:
                        r -= 1
                    l += 1
                    r -= 1
                elif s > 0:
                    r -= 1
                else:
                    l += 1
                
        return ans

```



## 4 42接雨水

可以看艾山零茶府的视频，讲得很清晰

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        n = len(height)
        pre_max, suf_max = [0] * n, [0] * n
        ans = 0
        pre_max[0] = height[0]
        for i in range(1, n):
            pre_max[i] = max(pre_max[i-1], height[i])
        suf_max[-1] = height[-1]
        for i in range(n - 2, -1, -1):
            suf_max[i] = max(suf_max[i+1], height[i])  
        for h, pre, suf in zip(height, pre_max, suf_max):
            ans += min(pre, suf) - h
        return ans
```

要注意两个问题，1.range里，第二个`stop`的-1 指的是0前面那个（即遍历到0截止），只有索引里的-1 才是最后一个。range(n)则是默认0——n-1
2.height老是拼写成hright 需要小心
