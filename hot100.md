# 1 哈希表

## 1 [1.两数之和](https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked)

`````python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dic = {}
        for i in range(len(nums)):
            if target - nums[i] in dic:
                return i, dic[target - nums[i]]
            else:
                dic[nums[i]] = i
`````



## 2.  [49.字母异位词分组](https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-100-liked)

**1.defaultdict(list) 可以创建一个默认的空列表**

```python
from collections import defaultdict

d = defaultdict(list)
d['a'].append('eat')
d['a'].append('tea')

print(d)
# {'a': ['eat', 'tea']}

```

**2.两个字母异位词，排序后一定完全相同***

```python
s = "tea"
sorted_s = sorted(s)
print(sorted_s)
#['a', 'e', 't']

```

也就是说：

> `sorted(s)` 会把字符串当作字符序列，然后按字母顺序返回一个**排序后的列表**。

但注意！
 它返回的是**列表**，不是字符串。
 所以我们通常要用 `''.join()` 把它拼回成字符串：

```python
sorted_s = ''.join(sorted(s))
print(sorted_s)
# "aet"

```


代码：

```python
from collections import defaultdict
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        ans = defaultdict(list)
        for s in strs:
            s_sorted = "".join(sorted(s))
            ans[s_sorted].append(s) # 这里类似于{'a': ['eat', 'tea']}
        
        return list(ans.values()) #这里需要注意 因为这里相当于是还要给答案转为list才符合题目要求。没有list只会输出一个可迭代对象
```



## 3 [128.最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked)

1.sort() 与sorted

**`sorted(iterable)`** 会返回一个**新的已排序列表**，不会在原对象上修改。

原对象如果是 `list`，它本身不会被改变。

`sorted()`：**返回一个新列表**（适用于任何可迭代对象）

`list.sort()`：**就地排序**，**返回值为 None**

```python
nums = [3, 1, 2]
res = sorted(nums)
print(res)   # [1, 2, 3]
print(nums)  # [3, 1, 2] 原列表没变
nums = [3, 1, 2]
nums.sort()
print(nums)  # [1, 2, 3]

```



```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        # 排序
        if not nums: return 0
        nums.sort()
        ans = 1
        seq = 1
        for i in range(len(nums) - 1):
            if nums[i + 1] - nums[i] == 1:
                seq += 1
            elif nums[i + 1] - nums[i] > 1:
                ans = max(ans, seq )
                seq = 1
        ans = max(ans, seq)   
        return ans
        # max(ans)
```



++++

# 2 双指针

## 1 移动零

**值得重新做**

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        if not nums: return 0
        j = 0
        for i in range(len(nums)):
            if nums[i]:
                nums[j] = nums[i]
                j += 1
        for i in range(j, len(nums)):
            nums[i] = 0
```

## 2  11.盛最多水的容器

在每个状态下，无论长板或短板向中间收窄一格，都会导致水槽 底边宽度 −1 变短：

若向内 移动短板 ，水槽的短板 min(h[i],h[j]) 可能变大，**因此下个水槽的面积 可能增大 。**
若向内 移动长板 ，水槽的短板 min(h[i],h[j]) 不变或变小，**因此下个水槽的面积 一定变小 。**
因此，初始化双指针分列水槽左右两端，循环每轮将短板向内移动一格，并更新面积最大值，直到两指针相遇时跳出；即可获得最大面积。

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        l = 0
        r = len(height) - 1
        ans = 0
        while l < r:
            water = min(height[l], height[r]) * (r - l)
            ans = max(water, ans)
            if height[l] < height[r]:
                l += 1
            else:
                r -= 1
        return ans

```

## 3  15.三数之和 [!]

***需要再做一遍，里面的去重等有点绕***

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        '''
        1，在同一个答案内，同一个数字只能使用一次
        2，三元组不可以重复
        '''
        #初始化及剪枝操作
        ans = []
        if not nums:
            return ans
        nums.sort()# 题目明确说明输出的顺序和三元组的顺序不重要
        if nums[0] > 0:
            return ans
        n = len(nums)
        
        # 开始固定i，利用双指针lr求解
        for i in range(n - 2):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            l = i + 1
            r = n - 1
            while l < r:
                s = nums[i] + nums[r] +nums[l]
                if s == 0:
                    ans.append([nums[i], nums[l], nums[r]])
                    while l < r and nums[l] == nums[l + 1]: 
                        l += 1
                    while l < r and nums[r] == nums[r - 1]:
                        r -= 1
                    l += 1
                    r -= 1
                elif s > 0:
                    r -= 1
                else:
                    l += 1
                
        return ans

```



## 4 42接雨水

可以看艾山零茶府的视频，讲得很清晰

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        n = len(height)
        pre_max, suf_max = [0] * n, [0] * n
        ans = 0
        pre_max[0] = height[0]
        for i in range(1, n):
            pre_max[i] = max(pre_max[i-1], height[i])
        suf_max[-1] = height[-1]
        for i in range(n - 2, -1, -1):
            suf_max[i] = max(suf_max[i+1], height[i])  
        for h, pre, suf in zip(height, pre_max, suf_max):
            ans += min(pre, suf) - h
        return ans
```

要注意两个问题，1.range里，第二个`stop`的-1 指的是0前面那个（即遍历到0截止），只有索引里的-1 才是最后一个。range(n)则是默认0——n-1
2.height老是拼写成hright 需要小心

# 3 滑动窗口

> 滑动窗口需要满足**单调性**。

## 1 3 无重复字符的最长自串

这里有两个值得学习的点 1是使用左指针与当前遍历的数字i维持滑动窗口2 是使用集合set{}来检查是否重复。由于set（）是可变的mutable，维护起来比字典也简单。

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        '''
        维护一个滑动窗口，使滑动窗口内的字符串没有重复的字母。可以将活动窗口看作一个队列在进行进队出队操作。
        '''
        if not s : return 0
        ans = 0
        cur_len = 0
        seen = set()
        n = len(s)
        left = 0 # 左指针
        for i in range(n):
            cur_len += 1
            while s[i] in seen: # 这里也很聪明：通过对seen的状态判断是否已经删除了所有的
                seen.remove(s[left])
                left += 1
                cur_len -= 1
            seen.add(s[i])
            ans = max(ans, cur_len) 
        return ans
```



## 2 438.找到字符串中所有字母异位词

容易想到使用滑动窗口进行检查，然后使用字典进行异位词的比较。

值得注意的地方 1. 滑动窗口的长度，right= le f t + 长度 -1 遍历的右端点也要加1

2. 维护字典时，删除时应该先判断字母的值为否为0 ， 为0再进行删除

```python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        '''
        滑动窗口+get
        '''
        
        p_l = len(p)
        s_l = len(s)
        ans = []
        if not s or p_l > s_l: return ans
        # left = 0
        
        p_dict = {}
        s_dict = {}
        for i in range(p_l):
            s_dict[s[i]] = s_dict.get(s[i], 0) + 1
        for i in p:
            p_dict[i] = p_dict.get(i, 0) + 1
        if s_dict == p_dict:
            ans.append(0)
        for left in range(1, s_l - p_l + 1):
            # 更新s_dict
            right = left + p_l - 1
            s_dict[s[left-1]] -= 1
            if s_dict[s[left-1]] == 0:
                del s_dict[s[left-1]]
            s_dict[s[right]] = s_dict.get(s[right], 0) + 1
            if s_dict == p_dict:
                ans.append(left)

        return ans
```

·

`s_dict[s[i]] = s_dict.get(s[i], 0) + 1`也比较好用，和`defaultdict`一样的作用

另，好像用Counter简单一点，见艾山灵茶府的解答。

```python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        ans = []
        cnt_p = Counter(p)  # 统计 p 的每种字母的出现次数
        cnt_s = Counter()  # 统计 s 的长为 len(p) 的子串 s' 的每种字母的出现次数
        for right, c in enumerate(s):
            cnt_s[c] += 1  # 右端点字母进入窗口
            left = right - len(p) + 1
            if left < 0:  # 窗口长度不足 len(p)
                continue
            if cnt_s == cnt_p:  # s' 和 p 的每种字母的出现次数都相同
                ans.append(left)  # s' 左端点下标加入答案
            out = s[left]
            cnt_s[out] -= 1  # 左端点字母离开窗口
            if cnt_s[out] == 0:
                del cnt_s[out]  # 注：目前力扣的 Python 版本是 3.11，不删除也可以，但在 3.12 中需要删除
        return ans

作者：灵茶山艾府
链接：https://leetcode.cn/problems/find-all-anagrams-in-a-string/solutions/2969498/liang-chong-fang-fa-ding-chang-hua-chuan-14pd/
```



+++

# 4 子串



## 1. 560 和为k的子数组 [!]

最开始看错题目了，没有注意到必须是子数组（即长度为n的连续的子串， n>=1）

**为什么不能用滑动窗口**：数组里可能有负数，导致导致滑动窗口不稳定。并且由于要求子串导致要求保持原数组的不变，不能使用sort

这道题使用前缀和+哈希表



![image-20251118103822372](../../Library/Application Support/typora-user-images/image-20251118103822372.png)

```python
from collections import defaultdict
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        ans = 0
        # 前缀和
        pre_sum = [0] * (len(nums) + 1)
      
        # 哈希表 定义每个前缀和出现的次数
        cnt = defaultdict(int)
        cnt[0] = 1 # 这里很重要：表示前缀和为0出现过一次了
        # 遍历数组
        for i in range(len(nums)) :
            pre_sum[i+1] = pre_sum[i] + nums[i]
            ans += cnt[pre_sum[i+1] - k]
            cnt[pre_sum[i+1]] += 1
        return ans
```



其实可以不需要前缀和数组，直接用一个pre的变量来表示前缀和，更简单也更好理解

```python
from collections import defaultdict
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        ans = 0
        # 前缀和
        pre_sum = 0
        # 哈希表 定义每个前缀和出现的次数
        cnt = defaultdict(int)
        cnt[0] = 1 # 这里很重要：表示前缀和为0出现过一次了
        # 遍历数组
        for x in nums:
            pre_sum += x
            ans += cnt[pre_sum - k]
            cnt[pre_sum] += 1
        return ans
```



## 2. 239滑动窗口最大值[!]

个人感觉这道题最好放在滑动窗口的类别里。

思路大致是使用单调队列+一次遍历。思路不太难，但是写起来容易出错

```python
from collections import deque
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        #使用单调队列来实现
        q = deque() # q储存的是下标，方便检查元素是否还在窗口内。q最左边的元素是这个窗口最大的元素
        ans = []
        for i, x in enumerate(nums):
            # 右边元素入队列
            while q and nums[q[-1]] <= x:
                q.pop() # 弹出队列所有比新的元素小的
            q.append(i)    
            
            # 左边元素出队列
            if q[0] < i - k + 1 :# 这个边界条件重要    
                q.popleft()
            # 记录队列左边的值（即为最大值）
            if i - k + 1 >= 0: # 窗口成型了再开始记录
                ans.append(nums[q[0]])
        return ans
```

发现出问题了，如果确定自己的思路没问题的话可以先检查边界条件。一般边界条件容易出错。另外，在写的时候老是把队列第一个元素写成q[-1], 说明还是把它和range有点搞糊涂了。在索引里-1是最后一个元素，0是第一个元素。

## 3.  76 最小覆盖子串 [!]

这道题还是比较清晰，看得出来是用滑动数组来解

只是不一定想得到需要一个valid来验证是否满足了所有的字母等等。值得复习

```python
from collections import Counter
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        '''
        用滑动窗口来做 
        '''
        # pruning
        if len(s) < len(t):
            return ""
        need = Counter(t)           # t'dict
        window = {}                 # sliding window's dict
        need_types = len(need)      # to cauculate the num of different letters in t
        valid = 0                   # how many different letters meet the need
        
        left = 0                    # left pointer

        ans_len = inf
        ans_start = 0

        for right, ch in enumerate(s):
            #ch gets into the window
            if ch in need:
                window[ch] = window.get(ch, 0) +1
                if window[ch] == need[ch]:
                    valid += 1
            while valid == need_types:
                # try to update the ans
                window_len = right - left + 1
                if window_len < ans_len:
                    ans_len = window_len
                    ans_start = left
                # cut the window
                l_ch = s[left]
                left += 1

                if l_ch in need:
                    if window[l_ch] == need[l_ch]:
                        valid -= 1
                    window[l_ch] -= 1
        return s[ans_start: ans_start + ans_len] if ans_len < inf else  ""            


```

# 5 普通数组

## 1.  53 最大子数组和

最开始经过简单的思考，觉得可以用前缀和来做，并且用前缀和确实简单、易理解

```python
from math import inf
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        '''
        方法1；用前缀和来做
        '''
        if not nums: return None      # pruning
        
        pre_sum = 0                   # current pre_sum
        min_pre = 0                   # the min pre_sum
        max_subarray = -inf                   

        for x in nums:
            pre_sum += x              # update pre_sum
            max_subarray = max(max_subarray, pre_sum - min_pre)
                                      # update max_subarray
            min_pre = min(pre_sum, min_pre)
                                      # update min_pre
        return max_subarray
```

这道题也可以用**动态规划DP**来做。

动态规划的步骤：

> 1.明确状态： dp[i] 代表什么
>
> 2.写出状态转移方程 如何从前一个状态dp[i - 1]推到当前状态dp[i]

在这道题里，dp[i] 代表：以i结尾的最大子数组和

状态转移方程：

dp[i] = max(nums[i], dp[i-1] + nums[i])

```python
from math import inf
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        '''
        用动态规划来做
        '''
        
        dp    = [0] * len(nums)       # initializae dp
        dp[0] = nums[0]
        ans   = dp[0]

        for i in range(1, len(nums)):
            dp[i] = max(nums[i], nums[i] + dp[i - 1])
            ans   = max(ans, dp[i])
        return ans
        
```

可以进一步优化

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:

        current_max = nums[0]
        max_subarray_sum = nums[0]

        for x in nums[1:]:
            current_max = max(x, current_max + x)
            max_subarray_sum = max(max_subarray_sum, current_max)

        return max_subarray_sum
```



## 2. 56 合并区间

```python
arr = [[1,3],[2,6],[8,10],[15,18]]
```

以上二维列表可以根据第一个列表的第一个元素进行排序

```python
arr.sort()
# 等价于一下形式
arr. sort(key = lambda x: x[0])
```



```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        '''
        大致思路：
        把区间按起点排序，然后开始合并
        '''
        intervals.sort(key = lambda x : x[0])
        # intervals.sort()  equally
        merged = []
        for  x in intervals:
            if not merged :
                merged.append([x[0], x[1]])
                continue
            else:    
                if x[0] <= merged[-1][1]:
                    merged[-1][1] = max(merged[-1][1], x[1])
                else:
                    merged.append([x[0], x[1]])
        return merged

```

## 3. 189轮转数组

```python
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        '''
        感觉可以用双端队列来做
        nums[:] = list(q)可以对nums进行原地修改
        '''
        from collections import deque
        
        if not nums: return None        # prune
        q = deque(nums)                 # initialize
        
        for i in range(k):
            q.appendleft(q.pop())
        
        nums[:] = list(q)
```



