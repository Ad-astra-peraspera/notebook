## 1 [1.两数之和](https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked)

`````python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dic = {}
        for i in range(len(nums)):
            if target - nums[i] in dic:
                return i, dic[target - nums[i]]
            else:
                dic[nums[i]] = i
`````



## 2.  [49.字母异位词分组](https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-100-liked)

**1.defaultdict(list) 可以创建一个默认的空列表**

```python
from collections import defaultdict

d = defaultdict(list)
d['a'].append('eat')
d['a'].append('tea')

print(d)
# {'a': ['eat', 'tea']}

```

**2.两个字母异位词，排序后一定完全相同***

```python
s = "tea"
sorted_s = sorted(s)
print(sorted_s)
#['a', 'e', 't']

```

也就是说：

> `sorted(s)` 会把字符串当作字符序列，然后按字母顺序返回一个**排序后的列表**。

但注意！
 它返回的是**列表**，不是字符串。
 所以我们通常要用 `''.join()` 把它拼回成字符串：

```python
sorted_s = ''.join(sorted(s))
print(sorted_s)
# "aet"

```


代码：

```python
from collections import defaultdict
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        ans = defaultdict(list)
        for s in strs:
            s_sorted = "".join(sorted(s))
            ans[s_sorted].append(s) # 这里类似于{'a': ['eat', 'tea']}
        
        return list(ans.values()) #这里需要注意 因为这里相当于是还要给答案转为list才符合题目要求。没有list只会输出一个可迭代对象
```



## 3 [128.最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked)

1.sort() 与sorted

**`sorted(iterable)`** 会返回一个**新的已排序列表**，不会在原对象上修改。

原对象如果是 `list`，它本身不会被改变。

`sorted()`：**返回一个新列表**（适用于任何可迭代对象）

`list.sort()`：**就地排序**，**返回值为 None**

```python
nums = [3, 1, 2]
res = sorted(nums)
print(res)   # [1, 2, 3]
print(nums)  # [3, 1, 2] 原列表没变
nums = [3, 1, 2]
nums.sort()
print(nums)  # [1, 2, 3]

```



```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        # 排序
        if not nums: return 0
        nums.sort()
        ans = 1
        seq = 1
        for i in range(len(nums) - 1):
            if nums[i + 1] - nums[i] == 1:
                seq += 1
            elif nums[i + 1] - nums[i] > 1:
                ans = max(ans, seq )
                seq = 1
        ans = max(ans, seq)   
        return ans
        # max(ans)
```

