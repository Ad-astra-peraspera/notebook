| 题目                                                         | 难度/知识点  | 关键知识点 |
| ------------------------------------------------------------ | ------------ | ---------- |
| [232.用栈实现队列](##用栈实现队列)  [url](https://leetcode.cn/problems/implement-queue-using-stacks/description/) | 简单/栈 队列 |            |
| [225.用队列实现栈](##用队列实现栈)  [url](https://leetcode.cn/problems/implement-stack-using-queues/description/) | 简单/栈 队列 |            |
| [20.有效的括号](##有效的括号) [url](https://leetcode.cn/problems/valid-parentheses/) | 简单/        |            |
| [1047.删除字符串的所有相邻重复项](##删除字符串中的所有相邻重复项)  [url](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/) | 简单         |            |

## 用栈实现队列

> 还是比较简单的，考察对于栈和队列的基本理解和掌握。

在python语法的md笔记里对栈和队列进行了简单的整理。

```python
class MyQueue:

    def __init__(self):
        self.instack = []
        self.outstack = []
        
    def push(self, x: int) -> None:
        self.instack.append(x)
        
    def pop(self) -> int:
        if not self.outstack:
            while self.instack:
                self.outstack.append(self.instack.pop())
        return self.outstack.pop()

    def peek(self) -> int:
        if not self.outstack:
            while self.instack:
                self.outstack.append(self.instack.pop())
        return self.outstack[-1]        

    def empty(self) -> bool:
        if self.outstack or self.instack:
            return False
        else:
            return True
```



+++



## 用队列实现栈

> 和上一道题很像，他们的核心思想其实都是用两个容器实现内部元素的重新排序。只是这道题想了很久都没有想明白怎么用两个队列实现元素顺序的改变。哈哈。

```python
class MyStack:
    from collections import  deque
    def __init__(self):
        self.q1 = deque()
        self.q2 = deque()

    def push(self, x: int) -> None:
            self.q2.append(x)
            while self.q1:
                self.q2.append(self.q1.popleft())
            self.q1,self.q2 = self.q2,self.q1

    def pop(self) -> int:
        return self.q1.popleft()
        
    def top(self) -> int:
        return self.q1[0]
        

    def empty(self) -> bool:
        if self.q1:
            return False
        else:
            return True
```

==另外==，要注意要调用在同一个类里的变量要用self。 deque 不是一个模块，而是 collections 模块中的一个**类**，不能用 import 的方式像模块一样导入它。（deque是用来创建对象的，所以是类）（模块是.py文件；包是包含多个模块的文件夹，是一个含有 __init__.py 文件的 **目录**）

+++

##  有效的括号

> 以前做过，有大致的印象。即用栈的思想，一旦遇到右括号，那么查看栈顶的元素是否与右括号相匹配。
>
> 使用字典进行匹配。

```python
class Solution:
    def isValid(self, s: str) -> bool:
        right_parettheses = {
            "}" : "{",
            "]" : "[",
            ")" : "("
        }
        stack = []
        for _ in s :
            if _ not in right_parettheses:
                stack.append(_)
            else:
                if not stack or stack[-1] != right_parettheses[_]:
                    return False
                stack.pop()
        return not stack
```



+++

## 删除字符串中的所有相邻重复项

> 思路：这道题的思路还是比较简单的。新建一个栈，当字符串中一个元素要被压入栈顶时，检查它是否与栈顶元素一致。

```python
class Solution:
    def removeDuplicates(self, s: str) -> str:
        stack = []
        for _ in s:
            if stack and _ == stack[-1]:
                stack.pop()
            else:
                stack.append(_)
        return "".join(stack)
```

如果不允许使用栈，可以用双指针实现。

```python
class Solution:
    def removeDuplicates(self, s: str) -> str:
        list_s = list(s)
        slow = fast = 0
        l = len(list_s)

        while fast < l:
            list_s[slow] = list_s[fast]
            if slow > 0 and list_s[slow] == list_s[slow-1]:
                slow -= 1
            else:
                slow += 1
            fast += 1
        return ''.join(list_s[0:slow])
```

有几个容易犯错的地方。

1 s是字符串无法直接索引，要把s转化成列表才行

2 最后返回的值是[0:slow]，而不是整个list

==这实际上是双指针模拟栈的思路==

slow指向的是栈的下一个位置，用它来匹配slow-1（栈顶元素），到最后返回整个栈中的元素（不包括slow，因为slow本身不在栈里面）
