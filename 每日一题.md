| [166.分数到小数](##分数到小数) [url](https://leetcode.cn/problems/fraction-to-recurring-decimal/?envType=daily-question&envId=2025-09-24) | 中等 | 哈希表、取整、格式输出 |
| ------------------------------------------------------------ | ---- | ---------------------- |
| [611.有效三角形的个数](##有效三角形的个数)[url](https://leetcode.cn/problems/valid-triangle-number/?envType=daily-question&envId=2025-09-26) | 中等 | 双指针                 |
|                                                              |      |                        |
|                                                              |      |                        |



----------

## 从分数到小数

最开始，我的疑问是怎么判断循环小数，接着我开始疑惑怎么判断无限不循环小数。

后面发现分数一定是有理数，即是不会出现无限不循环小数。

这道题的精髓其实是使用余数来判断是否可除尽。即代码中的remainder。

```python
class Solution:
    def fractionToDecimal(self, numerator: int, denominator: int) -> str:
        ''' 
        难点有2: 1.将数字转化为字符串（不难，用格式输出） 2.判断循环小数.
        如果是循环小数，那么还需要将循环的最小部分截断放入括号内（
循环节).
        此外，还要注意，python的 // 是向下取整！
        '''
        
        # 用追踪余数来做.
        sign = '-' if numerator * denominator < 0 else ''# 记录正负号
        numerator, denominator = abs(numerator), abs(denominator)
        int_part = numerator // denominator # 整数部分       
        remainder = numerator % denominator # 每一轮的余数
        decimals = '' # 用以记录余数
        seen = defaultdict(int) # 使用一个哈希表来记录出现过的余数
    
        # 开始验证是否是有循环，最开始没有余数即整除，直接返回整数部分
        if remainder == 0:
            return f'{sign}{int_part}'

        while remainder and remainder not in seen:
            seen[remainder] = len(decimals)
            remainder *= 10
            decimals += str(remainder // denominator)
            remainder %= denominator
        
        if remainder == 0: # 如果while循环结束remiander为0，说明不循环
            return f'{sign}{int_part}.{decimals}'
        else: # 注意，循环小数可能是从小数的某一部分开始循环，例如 1 / 6 = 0.16666... 
            repeat_start = seen[remainder]
            # 这个时候的remiander非0，并且被seen哈希表记录了第一次出现在decimals的位置
            non_repeat = decimals[:repeat_start]
            repeat = decimals[repeat_start:]
            return f'{sign}{int_part}.{non_repeat}({repeat})'
```

-------



## 有效的三角形的个数

最开始我联想到之前做的一道题，即是可以使用元组、哈希表来完成，但是这道题相同的数字是”作为不同的三角形的边“，要能构成的三角形的个数。

这道题的主要问题是判断三角形，而判断三角形则是要求两边之和大于第三边——>==那么只需要判断较短的两边大于第三边即可。==



```python
class Solution:
    def triangleNumber(self, nums: List[int]) -> int:
        '''
        简单思考后觉得可以使用哈希表来完成，后面发现使用哈希表的话同一个数字无法作为两条边
        '''
        nums.sort()# 将nums排序
        result = 0
        if len(nums) < 3: return result
        
        for k in range(2, len(nums)):# 大循环是固定最长边
            i, j = 0, k - 1
            while i < j:
                if nums[i] + nums[j] > nums[k]:
                    result += j - i # 这里是固定了j和k，算得是i～j之间所有的
                    j -= 1
                else:
                    i += 1
        return result
```

